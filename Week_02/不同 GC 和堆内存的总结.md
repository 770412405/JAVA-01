# 不同 GC 和堆内存的总结

串行  SerialGC

\#Serial是用于新生代单线程的收集器，采用复制算法进行垃圾收集 	serial 进行垃圾收集的时候，不仅只用一条线程执行垃圾收集工作，它在收集数据的同时，所有的用户线程必须暂停（Stop The World）。当用户线程都执行到安全点的时候，所有的线程暂停执行，Serial收集器以单线程，采用复制算法进行垃圾收集工作，收集完之后，用户线程开始执行 	 * 适用场景： 	Client 模式；单核服务器 	 可以使用-XX:+UserSerialGC 来选择Serial作为新生代收集器。 SerialGC ，堆内存大小越大，对初始化时 做的GC时间没有影响，但内存越大GC次数越少，并耗时越少。运行期间中，堆内存大小越大平均耗时越大，最大请求时间也会变大。

 并行ParallelGC 

 Paraller Scavenge 收集器也是一款用于新生代的多线程收集器 ，与ParNew 的不同之处是ParNew 的目标是尽可能的缩短垃圾收集时用户线程的停顿时间，Parller Scavenge 的目标是达到一个可控制的吞吐量。吞吐量：吞吐量 就是CPU执行用户线程的时间与CPU执行总时间的比值 ，吞吐量 = 运行用户代码的时间/(运行用户代码的时间+垃圾回收的时间 ) 	 	比如虚拟机一共运行了100分钟，其中垃圾回收使用了1分钟，那么吞吐量就是99%。是Paraller 收集器在新生代，当用户线程都执行到安全点时，所有线程暂停执行，Paraller Scavenge 收集器以多线程，采用复制算法进行收集工作，收集完之后，用户线程继续开始工作。 	 	在老年代，当用户线程都执行到安全点的时候，所有线程暂停工作，Paraller Old收集器以多线程，采用标记整理算法进行垃圾收集工作。  * 适用场景： 	注重吞吐量，高效利用CPU,需要高效运算且不需要太多交互 	 * 可以使用 -XX:+UseParallelGC 来选择Parallel Scavenge 作为新生代收集器 # jdk7、jdk8 默认使用 Parallel Scavenge 作为新生代收集器。  * 可以通过 -XX:MaxGCPauseMillis 来设置收集器尽可能在多长时间内完成内存回收 * 可以通过 -XX:GCTimeRatio 来精确控制吞吐量。堆内存大小越大，对初始化时做的GC时间没有影响，但内存越大GC次数越少，并且总耗时越少，在运行期间，平均耗时也就越大，但最大请求时间并没有没有影响。

 CMS

 CMS 收集器是一种以最短回收停顿时间为目标的收集器，以“最短时间用户停顿时间”著称。使用的是标记清除算法 * 整个垃圾回收过程分为4个步骤： 

1. 初始标记： 	标记一下GC Roots 能直接关联到的对象，速度较快。 	
2.  并发标记： 	进行GC Roots Tracing, 标记出全部的垃圾对象，耗时较长。 	 
3. 重新标记： 	修正并发标记阶段因用户程序继续运行而导致变化的对象的标记记录，耗时较短。 
4. 并发清除： 	用标记-清除算法清除垃圾对象，耗时较长 	
   * 整个过程耗时最长的并发标记和并发清除都是和用户线程一起工作，所以总体上来说， 	CMS收集器收集可以看做是和用户线程并发执行的。  # 使用场景 	重视服务器的响应速度，要求系统提顿时间最短 	可以使用 -XX:+UserConMarkSweepGC 来选择 CMS 作为老年代收集器		
   *  # 缺点：  	1、对CPU资源敏感： 		默认分配的垃圾回收线程数为（CPU数+3）/4,随着CPU数量下降，占用CPU资源越多，吞吐量越小 		 	                                                                      2、无法浮动处理垃圾： 在并发清理阶段，由于用户线程还在运行，还会不断的产生新的垃圾，CMS收集器无法在当次收集中清除这部分垃圾。同时由于在垃圾收集阶段（并发标记）阶段用户线程也在并发执行，CMS收集器不能像其他收集器那样等老年代被填满时在进行收集，需要预留一部分空间提供用户线程运行使用。当CMS运行的时候，预留的空间无法满足用户线程的需要，就会出现 “ Concurrent Mode Failure ”的错误，这时将会启动后备预案，临时用 Serial Old 来重新进行老年代的垃圾收集。因为CMS是基于标记清除算法的，所以垃圾回收后会产生空间碎片：可以通过-XX:UserCMSCompactAtFullCollection 开启碎片整理（默认开启）        	        	在CMS进行Full GC之前，会进行内存碎片的整理。还可以用XX:CMSFullGCsBeforeCompaction 设置执行多少次不压缩（不进行碎片整理）的 Full GC 之后，跟着来一次带压缩（碎片整理）的 Full GC。		

堆内存大小越大，对初始化时做的GC时间没有影响，但内存越大GC次数越少，总耗时没什么影响，运行期间时，平均耗时会根据内存变大而变大，最大请求时间也没有受到影响

G1

\# G1 进行垃圾收集的范围是整个堆内存,是jdk1.7才正式引用的商用收集器。现在jdk9默认的收集器； 	它采用的是“化整为零”的思路。把整个堆内存划分为多个大小相等的独立区域（Region），在 G1 收集器中还保留着新生代和老年代的概念，它们分别都是一部分 Region  1. 每一个方块就是一个区域，每个区域可能是Eden,Survivor,老年代。每种区域的数量也不一定。 	JVM启动的时候，会自动设置每个区域的大小（1M~32M,必须是2的次幂）， 	最多可以设置2048个区域（即支持的最大的堆内存为32M*2048 = 64G）， 	假如设置 -Xmx8g ,-Xms8g,则每个区域大小为8g/2048 = 4M; 	 	 * 为了在GC Roots Tracing 的时候避免扫描全堆，在每个Region中，都有一个 Remembered Set 来实时记录该区域内的引用类型数据与其他区域数据的引用关系，在标记时直接参考这些引用关系就可以知道这些对象是否应该被清除，而不用扫描全堆的数据。		 * G1 收集器可以 “ 建立可预测的停顿时间模型 ”，它维护了一个列表用于记录每个 Region 回收的价值大小（回收后获得的空间大小以及回收所需时间的经验值），这样可以保证 G1 收集器在有限的时间内可以获得最大的回收效率。

\# G1收集器收集的过程有： 1、初始标记 2、并发标记 3、最终标价 4、筛选回收 和CMS收集器的前几步过程很像  1. 初始标记： 	标记出 GC Roots 直接关联的对象，这个阶段速度较快，需要停止用户线程，单线程执行。 	 2. 并发标记： 	从 GC Root 开始对堆中的对象进行可达新分析，找出存活对象，这个阶段耗时较长，但可以和用户线程并发执行。 	 3. 最终标记： 	修正在并发标记阶段引用户程序执行而产生变动的标记记录。 	 4.  筛选回收： 	筛选回收阶段会对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来指定回收计划（用最少的时间来回收包含垃圾最多的区域，这就是 Garbage First 的由来——第一时间清理垃圾最多的区块），这里为了提高回收效率，并没有采用和用户线程并发执行的方式，而是停顿用户线程。  # 使用场景： 	要求尽可能可控 GC 停顿时间；内存占用较大的应用。 	可以使用 -XX:+UseG1GC 使用 G1 收集器，jdk9 默认使用 G1 收集器。

堆内存大小越大，对初始化时做的GC时间没有影响，内存越大，会导致总共GC次数越少，总耗时越小，运行期间时，平均耗时也会越大，最大请求时间也没有受到影响